<?php

require_once('metadata.inc');

$all_metadata = get_metadata();
$node_info = array();

// TODO: Extend CCK's 'manage fields' interface so that we can exclude wrapped fields from search, rss, and teaser view
// TODO: Document how to define metadata.inc
// TODO: Create a sync function instead of a hook_update_n to run with cron and check for new legacy items
// TODO: 

/**
 * Implementation of hook_access().
 *
 * Named so as not to conflict with node_access(). Basically sets up the same
 * exact permissions as node.module does. 
 */
function hugs_access($op, $node, $account) {
  $type = is_string($node) ? $node : (is_array($node) ? $node['type'] : $node->type);

  if ($op == 'create') {
    return user_access('create '. $type .' content', $account);
  }

  if ($op == 'update') {
    if (user_access('edit any '. $type .' content', $account) || (user_access('edit own '. $type .' content', $account) && ($account->uid == $node->uid))) {
      return TRUE;
    }
  }

  if ($op == 'delete') {
    if (user_access('delete any '. $type .' content', $account) || (user_access('delete own '. $type .' content', $account) && ($account->uid == $node->uid))) {
      return TRUE;
    }
  }
}

function hugs_views_api() {
  return array('api' => 2.0);
}

function hugs_views_handlers() {
  return array(
    'handlers' => array(
      'hugs_handler_field' => array(
        'parent' => 'views_handler_field',
        'file' => 'hugs_handler_field.inc',
      ),
    ),
  );
}

/**
 * Implementation of hook_node_info().
 */
function hugs_node_info() {
  return get_node_info();
}

/**
 * Implementation of hook_perm().
 *
 * Basically the same exact thing as node.module. Allows fairly refined control
 * over all editing aspects of the legacy nodes. 
 */
function hugs_perm() {
  $perms = array();
  
  foreach (node_get_types() as $type) {
    if ($type->module == 'hugs') {
      $name = check_plain($type->type);
      $perms[] = 'create '. $name .' content';
      $perms[] = 'delete own '. $name .' content';
      $perms[] = 'delete any '. $name .' content';
      $perms[] = 'edit own '. $name .' content';
      $perms[] = 'edit any '. $name .' content';
    }
  }

  return $perms;
}

/**
 * Implementation of hook_load().
 */
function hugs_load($node) {
  // Make sure that we only load a node once. After that we should skip the node_load
  // and just return the correct object. 
  static $nodes = array();
  
  $nodes[$node->nid] = is_object($node) ? drupal_clone($node) : $node;
  
  $metadata = get_metadata($node);
  
  $node = hugs_load_without_friends($node);

  // Horibly brittle hack to ensure searching doesn't hose
  $backtrace = debug_backtrace();
  if ($backtrace[4]['function'] == 'node_update_index') {
    return $node;
  }
  
  // Load up any parents
  if ($metadata['belongs_to']) {
    foreach ($metadata['belongs_to'] as $drupal_attr => $legacy_attr) {
      // Only load in one direction, when we load up a child it shouldn't load up all its children too
      if ($node->parent != $drupal_attr) {
        // See if we've loaded the node before, if so just return a reference
        $collection = $drupal_attr . "_collection";

        $node->$collection = array();
        $sql = "SELECT * FROM node, $drupal_attr as extra WHERE node.nid = extra.nid AND node.nid = ". $node->$drupal_attr;
        $obj = db_fetch_object(db_query($sql));
        $obj->parent = $node->type;
        array_push($node->$collection, hugs_load_without_friends($obj));
      }
    }
  }

  // Load any children
  if ($metadata['has_many'] && $node->nid) {
    foreach ($metadata['has_many'] as $drupal_attr => $legacy_attr) {
      // Only load in one direction, when we load up a child it shouldn't load up all its children too
      if (!$node->parent) {
        $collection = $drupal_attr . "_collection";
      
        // Get the list of things this object owns
        $sql = "SELECT * FROM node, $drupal_attr as extra WHERE node.nid = extra.nid AND extra.". $node->type ." = ". $node->nid;
        $res = db_query($sql);
      
        // node_load all children and drop them in an array
        $node->$collection = array();
        while ($obj = db_fetch_object($res)) {
          $obj->parent = $node->type;
          array_push($node->$collection, hugs_load($obj));
        }
      }
    }
  }
  
  return $node;
}

function hugs_load_without_friends($node) {
  $metadata = get_metadata($node);
  
  // Load up linking information and extra info from the node addon table
  if ($node->nid) {
    $sql = "SELECT * FROM ". $node->type ." WHERE nid = ". $node->nid;
    $extra_attributes = db_fetch_object(db_query($sql));
    foreach ($extra_attributes as $key => $value) {
      $node->$key = $value;
    }
  }
  
  // Load up from the legacy table
  if ($node->refid) {
    $sql = "SELECT";
    $sql_attr = array(" *");
    if ($metadata['rw_attribute_mapping']) {
      foreach ($metadata['rw_attribute_mapping'] as $drupal_attr => $legacy_attr) {
        $column_name = column_name($legacy_attr);
        $sql_attr[] = "$column_name as $drupal_attr";
      }
    }
    if ($metadata['ro_attribute_mapping']) {
      foreach ($metadata['ro_attribute_mapping'] as $drupal_attr => $ro_attr) {
        $sql_attr[] = "$ro_attr as $drupal_attr";
      }
    }
    $sql .= implode(', ', $sql_attr);
    $sql .= " FROM ". $metadata['table_mapping'] ." as legacy WHERE legacy.". $metadata['primary_key'] ." = ". $node->refid;
  
    // Add these attributes onto the node object
    $legacy_attributes = db_fetch_object(db_query($sql));
    if ($legacy_attributes) {
      foreach ($legacy_attributes as $key => $value) {
        // Handle file uploads
        if ($value && is_array($metadata['rw_attribute_mapping'][$key]) && $metadata['rw_attribute_mapping'][$key]['type'] == 'upload_element') {
          $node->$key = db_fetch_object(db_query("SELECT * FROM files WHERE fid = ". $value));
        }
        // Handle all other rw attributes
        else {
          $node->$key = $value;
        }
      }
    }
  }
  
  return $node;
}

function column_name($legacy_attr) {
  return (is_array($legacy_attr) && $legacy_attr['name']) ? $legacy_attr['name'] : $legacy_attr;
}

function hugs_form($node) {
  // Pull up the metadata filtered by node type. If we're editing a node we pass that
  // in as well so that the default values are populated correctly. 
  $metadata = get_metadata($node);
  
  // Pull up title/body info and display fields if necessary
  $node_info = get_node_info();
  
  $form = array();

  // If we found some form definitions rejoice and modify the form.
  if (!empty($metadata['rw_attribute_mapping'])) {
    foreach ($metadata['rw_attribute_mapping'] as $drupal_attr => $legacy_attr) {
      $form[$drupal_attr] = array(
        '#type' => 'textfield',
        '#title' => t(titleize($drupal_attr)),
      );
      
      // This allows the entire stack to be specified by either an array with options:
      // name, type, and options or none of these things. 
      if (is_array($legacy_attr)) {
        if ($legacy_attr['name']) {
          $form[$drupal_attr]['#default_value'] = $node->$drupal_attr;
        }
        if ($legacy_attr['type']) {
          $form[$drupal_attr]['#type'] = $legacy_attr['type'];
          if ($legacy_attr['type'] == 'date') {
            if ($node->$drupal_attr) {
              $form[$drupal_attr]['#default_value'] = array(
                'month' => format_date($node->$drupal_attr, 'custom', 'n'),
                'day'   => format_date($node->$drupal_attr, 'custom', 'j'),
                'year'  => format_date($node->$drupal_attr, 'custom', 'Y'),
              );
            }
            else {
              $form[$drupal_attr]['#default_value'] = array(
                'month' => format_date(time(), 'custom', 'n'),
                'day'   => format_date(time(), 'custom', 'j'),
                'year'  => format_date(time(), 'custom', 'Y'),
              );
            }
          }
        }
        if ($legacy_attr['options']) {
          foreach ($legacy_attr['options'] as $key => $value) {
            $form[$drupal_attr][$key] = $value;
          }
        }
      }
      
      // If the options coming in aren't an array just use them like a textfield
      else {
        $form[$drupal_attr]['#default_value'] = $node->$legacy_attr;
      }
    }    
  }
  
  if ($node_info[$node->type]['has_title']) {
    $form['title'] = array(
      '#type' => 'textfield',
      '#title' => $node_info[$node->type]['title_label'],
      '#default_value' => $node->title,
    );
  }
  if ($node_info[$node->type]['has_body']) {
    $form['body'] = array(
      '#type' => 'textarea',
      '#title' => $node_info[$node->type]['body_label'],
      '#default_value' => $node->body,
    );
  }
  
  if ($metadata['belongs_to']) {
    foreach ($metadata['belongs_to'] as $drupal_attr => $legacy_attr) {
      $default_value = ($node->$drupal_attr) ? select_flattened_array_from_sql('nid', "SELECT * FROM $drupal_attr as extra WHERE nid = ". $node->$drupal_attr, $node->type) : array();
      $allow_blank = true;
  
      $form[$drupal_attr] = array(
        '#title' => t(titleize($drupal_attr)),
        '#type' => 'select',
        '#options' => select_options_from_sql('nid', 'title', "SELECT * FROM $drupal_attr as extra, node WHERE node.nid = extra.nid", $allow_blank, $node->type),
        '#description' => t('A foreign association to the %table-name table.', array('%table-name' => titleize($drupal_attr))),
        '#default_value' => $default_value,
      );
      if (user_access('administer data')) {
        $form[$drupal_type]['#description'] .=  "<br />". l('Click here to add a new ' . titleize($drupal_type), 'node/add/' . preg_replace('/[_]/', '-', $drupal_type));
      }
      // Don't show fields if there's nothing to display and the user lacks the permissions to add new items
      if (empty($form[$drupal_type]['#description'])) {
        unset($form[$drupal_type]);
      }
    }
  }
  
  // Only display has_many when the node already exists. Otherwise it just doesn't make much sense.
  if ($node->nid) {
    if ($metadata['has_many']) {
      foreach ($metadata['has_many'] as $drupal_type => $foreign_key) {
        $description = NULL;
        $collection = $drupal_type . "_collection";
        if ($node->$collection) {
          foreach ($node->$collection as $key => $foreign_node) {
            $title = (isset($foreign_node->title)) ? $foreign_node->title : titleize($foreign_node->type) . ": ". $foreign_node->nid;
            $description .= l($title, 'node/' . $foreign_node->nid);
          }
        }
      
        $form[$drupal_type] = array(
          '#type' => 'item',
          '#title' => t(titleize($drupal_type)),
          '#description' => $description,
        );
        if (user_access('administer data')) {
          $form[$drupal_type]['#description'] .= "<br />". l('Click here to add a new ' . titleize($drupal_type), 'node/add/' . preg_replace('/[_]/', '-', $drupal_type));
        }
        // Don't show fields if there's nothing to display and the user lacks the permissions to add new items
        if (empty($form[$drupal_type]['#description'])) {
          unset($form[$drupal_type]);
        }
      }
    }
  }
  
  // Add in the legacy reference field
  if ($node->refid) {
    $form['refid'] = array(
      '#type' => 'hidden',
      '#value' => $node->refid,
    );
  }
  
  return $form;
}

/**
 * Implementation of hook_content_extra_fields().
 */
function hugs_content_extra_fields($type) {
  $node = new stdClass();
  $node->type = $type;  
  $metadata = get_metadata($node);
  
  // Pull up title/body info and display fields if necessary
  $node_info = get_node_info();
  
  $extras = array();

  if (!empty($metadata['rw_attribute_mapping'])) {
    foreach ($metadata['rw_attribute_mapping'] as $drupal_attr => $legacy_attr) {
      // Don't weight the title, drupal will do this for us
      if ($drupal_attr != 'title') {
        // Otherwise, give a weight to all other rw attrs
        $extras[$drupal_attr] = array(
          'label' => titleize($drupal_attr),
        );
      }
    }    
  }
  
  if ($metadata['belongs_to']) {
    foreach ($metadata['belongs_to'] as $drupal_attr => $legacy_attr) {
      $extras[$drupal_attr] = array(
        'label' => titleize($drupal_attr),
        'description' => 'A foreign association to the %table-name table.', array('%table-name' => titleize($drupal_attr)),
      );
    }
  }
  
  if ($metadata['has_many']) {
    foreach ($metadata['has_many'] as $drupal_attr => $legacy_attr) {
      $extras[$drupal_attr] = array(
        'label' => titleize($drupal_attr),
        'description' => 'A foreign association to the %table-name table.', array('%table-name' => titleize($drupal_attr)),
      );
    }
  }
  
  return $extras;
}

/**
 * Implementation of hook_view().
 */
function hugs_view($node, $teaser = FALSE, $page = FALSE) {
  $metadata = get_metadata($node);
  
  $node = node_prepare($node, $teaser);
  
  $node = hugs_view_without_friends($node, $teaser, $page);
  
  if ($metadata['belongs_to']) {
    foreach ($metadata['belongs_to'] as $drupal_attr => $legacy_attr) {
      if ($node->parent != $drupal_attr) {
        $rows = array();
        
        $collection = $drupal_attr . "_collection";
      
        if ($node->$collection) {
          foreach ($node->$collection as $child) {
            $child->parent = $node->type;
            $view = hugs_view_without_friends($child, $teaser, $page);
            node_invoke_nodeapi($view, 'view', $teaser, $page);
            $rows[] = $view->content;
          }
        }

        $node->content[$drupal_attr] = $rows;
        $node->content[$drupal_attr]['#weight'] = content_extra_field_weight($node->type, $drupal_attr);
      }
    }
  }
  
  if ($metadata['has_many']) {
    foreach ($metadata['has_many'] as $drupal_attr => $legacy_attr) {
      if (!$node->parent) {
        $rows = array();

        $collection = $drupal_attr . "_collection";
      
        if ($node->$collection) {
          foreach ($node->$collection as $child) {
            $child->parent = $node->type;
            $view = hugs_view($child, $teaser, $page);
            node_invoke_nodeapi($view, 'view', $teaser, $page);
            $rows[] = $view->content;
          }
        }

        $node->content[$drupal_attr] = $rows;
        $node->content[$drupal_attr]['#weight'] = content_extra_field_weight($node->type, $drupal_attr);
      }
    }    
  }
    
  return $node;
}

function hugs_view_without_friends($node, $teaser, $page) {
  $metadata = get_metadata($node);
  
  // Pull up title/body info and display fields if necessary
  static $node_info;
  
  if (!$node_info) {
    $node_info = get_node_info();
  }
  
  if ($metadata['ro_attribute_mapping']) {
    foreach ($metadata['ro_attribute_mapping'] as $drupal_attr => $ro_attr) {
      $node->content[$drupal_attr] = array(
        '#value' => theme('section', array('title' => $drupal_attr, 'elements' => array($node->$drupal_attr))),
        '#weight' => content_extra_field_weight($node->type, $drupal_attr),
      );
    }
  }
  
  if ($metadata['rw_attribute_mapping']) {
    foreach ($metadata['rw_attribute_mapping'] as $drupal_attr => $legacy_attr) {
      // Handle file uploads
      if (is_array($legacy_attr) && $legacy_attr['type'] == 'upload_element') {
        $node->content[$drupal_attr] = array(
          '#value' => theme('upload_element_preview', array("#value" => $node->$drupal_attr)),
          '#weight' => content_extra_field_weight($node->type, $drupal_attr),
        );
      }
      // Handle all other rw data
      else {
        $column_name = column_name($legacy_attr);
        $node->content[$drupal_attr] = array(
          '#value' => theme('section', array('title' => $drupal_attr, 'elements' => array($node->$column_name))),
          '#weight' => content_extra_field_weight($node->type, $drupal_attr),
        );
      }
    }
  }
  
  return $node;
}

/**
 * Implementation of hook_theme().
 */
function hugs_theme() {
  return array(
    'section' => array(
      'arguments' => array('elements' => NULL),
      'template' => 'element',
    ),
  );
}

/**
 * Implementation of hook_form_alter().
 */
function hugs_form_alter(&$form, $form_state, $form_id) {

}

/**
 * Take some sql and return a mapping between two attributes in some sql
 */
function select_options_from_sql($col1, $col2, $sql, $extra_blank = false, $parent_node_type) {
  $sql = module_invoke_all('reduce_options', $sql, $parent_node_type);
  $sql = $sql[0];

  $res = db_query($sql);
  $rows = array();
  
  if ($extra_blank) {
    $rows[] = '';
  }
  while ($opt = db_fetch_array($res)) {
    $rows[$opt[$col1]] = $opt[$col2];
  }
  
  return $rows;
}

function select_flattened_array_from_sql($col1, $sql, $parent_node_type) {
  $sql = module_invoke_all('reduce_options', $sql, $parent_node_type);
  $sql = $sql[0];
  
  $res = db_query($sql);
  $rows = array();
  
  while ($opt = db_fetch_array($res)) {
    $rows[] = $opt[$col1];
  }
    
  return $rows;
}

/**
 * Implementation of hook_delete().
 */
function hugs_delete($node) {
  $metadata = get_metadata($node);
  
  db_query("DELETE FROM %s WHERE %s = %d", $metadata['table_mapping'], $metadata['primary_key'], $node->refid);
  db_query("DELETE FROM %s WHERE nid = %d", $node->type, $node->nid);
}

/**
 * Implementation of hook_insert().
 */
function hugs_insert($node) {
  $metadata = get_metadata($node);
  
  if (!$node->refid) {
    // Insert into the legacy table
    $sql = "INSERT INTO %s SET ";
    $sql_vars = array($metadata['table_mapping']);
    $sql_attr = array();
  
    if ($metadata['rw_attribute_mapping']) {
      foreach ($metadata['rw_attribute_mapping'] as $drupal_attr => $legacy_attr) {
        if ($legacy_attr['type'] == 'upload_element') {
          $node->$drupal_attr = upload_element_save($node->$drupal_attr, 'sites/default/files', FILE_EXISTS_RENAME, 'imagecache_preset');
        }
        
        $column_name = column_name($legacy_attr);
        $sql_attr[] = "$column_name = \"%s\"";
        $sql_vars[] = $node->$drupal_attr;
      }
    }
  
    // Update the foreign key associations on the legacy table
    if ($metadata['belongs_to']) {
      $table_mapping = _get_table_mapping();
      foreach ($metadata['belongs_to'] as $drupal_attr => $legacy_attr) {
        if ($node->$drupal_attr) {
          $sql_attr[] = "$legacy_attr = (SELECT refid FROM %s WHERE nid = %d)";
          $sql_vars = array_merge($sql_vars, array($drupal_attr, $node->$drupal_attr));
        }
      }
    }
  
    db_query($sql . implode(", ", $sql_attr), $sql_vars);
  
    $node->refid = db_result(db_query('SELECT LAST_INSERT_ID()'));
  }
  
  // Insert into the drupal extra table
  $sql = "INSERT INTO %s SET ";
  $sql_vars = array($node->type);
  
  $sql_attr = array();
  $sql_attr[] = "nid = %d";
  $sql_attr[] = "vid = %d";
  $sql_attr[] = "refid = %d";
  $sql_vars = array_merge($sql_vars, array($node->nid, $node->vid, $node->refid));
  
  if ($metadata['belongs_to']) {
    foreach ($metadata['belongs_to'] as $drupal_attr => $legacy_attr) {
      if ($node->$drupal_attr) {
        $sql_attr[] = "%s = %s";
        $sql_vars = array_merge($sql_vars, array($drupal_attr, $node->$drupal_attr));
      }
    }
  }

  db_query($sql . implode(", ", $sql_attr), $sql_vars);
}

/**
 * Implementation of hook_update().
 */
function hugs_update($node) {
  $metadata = get_metadata($node);
  
  // Update the legacy table
  if ($metadata['rw_attribute_mapping']) {
    $sql = "UPDATE %s SET ";
    $sql_vars = array($metadata['table_mapping']);
    
    $sql_attr = array();
    foreach ($metadata['rw_attribute_mapping'] as $drupal_attr => $legacy_attr) {
      if ($legacy_attr['type'] == 'upload_element') {
        $node->$drupal_attr = upload_element_save($node->$drupal_attr, 'sites/default/files', FILE_EXISTS_RENAME, 'imagecache_preset');
      }
      
      $column_name = column_name($legacy_attr);
      $sql_attr[] = "%s = \"%s\"";
      $sql_vars = array_merge($sql_vars, array($column_name, $node->$drupal_attr));
    }
    $sql = $sql . implode(", ", $sql_attr);
    $sql .= " WHERE %s = %d ";
    $sql_vars = array_merge($sql_vars, array($metadata['primary_key'], $node->refid));
    
    db_query($sql, $sql_vars);
  }
  
  if ($metadata['belongs_to']) {
    // Update the drupal table
    $sql = "UPDATE %s SET ";
    $sql_vars = array($node->type);
    
    $sql_attr = array();
    foreach ($metadata['belongs_to'] as $drupal_attr => $legacy_attr) {
      if ($node->$drupal_attr) {
        $sql_attr[] = "%s = %s";
        $sql_vars = array_merge($sql_vars, array($drupal_attr, $node->$drupal_attr));
      }
    }
    
    if (sizeof($sql_attr) > 0) {
      $sql = $sql . implode(", ", $sql_attr);
      $sql .= " WHERE nid = %d";
      $sql_vars = array_merge($sql_vars, array($node->nid));

      db_query($sql, $sql_vars);
    }
    
    // Update the foreign key associations on the legacy table
    $table_mapping = _get_table_mapping();
    foreach ($metadata['belongs_to'] as $drupal_attr => $legacy_attr) {
      if ($node->$drupal_attr) {
        $sql = "UPDATE %s SET %s = (SELECT refid FROM %s WHERE nid = %d) WHERE %s = %d";
        $sql_vars = array($metadata['table_mapping'], $legacy_attr, $drupal_attr, $node->$drupal_attr, $metadata['primary_key'], $node->refid);
        db_query($sql);
      }
    }
  }
}